import{indexOf,lst}from"../util/misc.js";import{cmp}from"./pos.js";import{sawCollapsedSpans}from"./saw_special_spans.js";import{getLine,isLine,lineNo}from"./utils_line.js";export function MarkedSpan(e,t,n){this.marker=e,this.from=t,this.to=n}export function getMarkedSpanFor(e,t){if(e)for(let n=0;n<e.length;++n){let r=e[n];if(r.marker==t)return r}}export function removeMarkedSpan(e,t){let n;for(let r=0;r<e.length;++r)e[r]!=t&&(n||(n=[])).push(e[r]);return n}export function addMarkedSpan(e,t,n){let r=n&&window.WeakSet&&(n.markedSpans||(n.markedSpans=new WeakSet));r&&e.markedSpans&&r.has(e.markedSpans)?e.markedSpans.push(t):(e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],r&&r.add(e.markedSpans)),t.marker.attachLine(e)}function markedSpansBefore(e,t,n){let r;if(e)for(let l=0;l<e.length;++l){let a=e[l],i=a.marker;if(null==a.from||(i.inclusiveLeft?a.from<=t:a.from<t)||a.from==t&&"bookmark"==i.type&&(!n||!a.marker.insertLeft)){let e=null==a.to||(i.inclusiveRight?a.to>=t:a.to>t);(r||(r=[])).push(new MarkedSpan(i,a.from,e?null:a.to))}}return r}function markedSpansAfter(e,t,n){let r;if(e)for(let l=0;l<e.length;++l){let a=e[l],i=a.marker;if(null==a.to||(i.inclusiveRight?a.to>=t:a.to>t)||a.from==t&&"bookmark"==i.type&&(!n||a.marker.insertLeft)){let e=null==a.from||(i.inclusiveLeft?a.from<=t:a.from<t);(r||(r=[])).push(new MarkedSpan(i,e?null:a.from-t,null==a.to?null:a.to-t))}}return r}export function stretchSpansOverChange(e,t){if(t.full)return null;let n=isLine(e,t.from.line)&&getLine(e,t.from.line).markedSpans,r=isLine(e,t.to.line)&&getLine(e,t.to.line).markedSpans;if(!n&&!r)return null;let l=t.from.ch,a=t.to.ch,i=0==cmp(t.from,t.to),o=markedSpansBefore(n,l,i),f=markedSpansAfter(r,a,i),p=1==t.text.length,m=lst(t.text).length+(p?l:0);if(o)for(let e=0;e<o.length;++e){let t=o[e];if(null==t.to){let e=getMarkedSpanFor(f,t.marker);e?p&&(t.to=null==e.to?null:e.to+m):t.to=l}}if(f)for(let e=0;e<f.length;++e){let t=f[e];null!=t.to&&(t.to+=m),null==t.from?getMarkedSpanFor(o,t.marker)||(t.from=m,p&&(o||(o=[])).push(t)):(t.from+=m,p&&(o||(o=[])).push(t))}o&&(o=clearEmptySpans(o)),f&&f!=o&&(f=clearEmptySpans(f));let s=[o];if(!p){let e,n=t.text.length-2;if(n>0&&o)for(let t=0;t<o.length;++t)null==o[t].to&&(e||(e=[])).push(new MarkedSpan(o[t].marker,null,null));for(let t=0;t<n;++t)s.push(e);s.push(f)}return s}function clearEmptySpans(e){for(let t=0;t<e.length;++t){let n=e[t];null!=n.from&&n.from==n.to&&!1!==n.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}export function removeReadOnlyRanges(e,t,n){let r=null;if(e.iter(t.line,n.line+1,(e=>{if(e.markedSpans)for(let t=0;t<e.markedSpans.length;++t){let n=e.markedSpans[t].marker;!n.readOnly||r&&-1!=indexOf(r,n)||(r||(r=[])).push(n)}})),!r)return null;let l=[{from:t,to:n}];for(let e=0;e<r.length;++e){let t=r[e],n=t.find(0);for(let e=0;e<l.length;++e){let r=l[e];if(cmp(r.to,n.from)<0||cmp(r.from,n.to)>0)continue;let a=[e,1],i=cmp(r.from,n.from),o=cmp(r.to,n.to);(i<0||!t.inclusiveLeft&&!i)&&a.push({from:r.from,to:n.from}),(o>0||!t.inclusiveRight&&!o)&&a.push({from:n.to,to:r.to}),l.splice.apply(l,a),e+=a.length-3}}return l}export function detachMarkedSpans(e){let t=e.markedSpans;if(t){for(let n=0;n<t.length;++n)t[n].marker.detachLine(e);e.markedSpans=null}}export function attachMarkedSpans(e,t){if(t){for(let n=0;n<t.length;++n)t[n].marker.attachLine(e);e.markedSpans=t}}function extraLeft(e){return e.inclusiveLeft?-1:0}function extraRight(e){return e.inclusiveRight?1:0}export function compareCollapsedMarkers(e,t){let n=e.lines.length-t.lines.length;if(0!=n)return n;let r=e.find(),l=t.find(),a=cmp(r.from,l.from)||extraLeft(e)-extraLeft(t);return a?-a:cmp(r.to,l.to)||extraRight(e)-extraRight(t)||t.id-e.id}function collapsedSpanAtSide(e,t){let n,r=sawCollapsedSpans&&e.markedSpans;if(r)for(let e,l=0;l<r.length;++l)e=r[l],e.marker.collapsed&&null==(t?e.from:e.to)&&(!n||compareCollapsedMarkers(n,e.marker)<0)&&(n=e.marker);return n}export function collapsedSpanAtStart(e){return collapsedSpanAtSide(e,!0)}export function collapsedSpanAtEnd(e){return collapsedSpanAtSide(e,!1)}export function collapsedSpanAround(e,t){let n,r=sawCollapsedSpans&&e.markedSpans;if(r)for(let e=0;e<r.length;++e){let l=r[e];l.marker.collapsed&&(null==l.from||l.from<t)&&(null==l.to||l.to>t)&&(!n||compareCollapsedMarkers(n,l.marker)<0)&&(n=l.marker)}return n}export function conflictingCollapsedRange(e,t,n,r,l){let a=getLine(e,t),i=sawCollapsedSpans&&a.markedSpans;if(i)for(let e=0;e<i.length;++e){let t=i[e];if(!t.marker.collapsed)continue;let a=t.marker.find(0),o=cmp(a.from,n)||extraLeft(t.marker)-extraLeft(l),f=cmp(a.to,r)||extraRight(t.marker)-extraRight(l);if(!(o>=0&&f<=0||o<=0&&f>=0)&&(o<=0&&(t.marker.inclusiveRight&&l.inclusiveLeft?cmp(a.to,n)>=0:cmp(a.to,n)>0)||o>=0&&(t.marker.inclusiveRight&&l.inclusiveLeft?cmp(a.from,r)<=0:cmp(a.from,r)<0)))return!0}}export function visualLine(e){let t;for(;t=collapsedSpanAtStart(e);)e=t.find(-1,!0).line;return e}export function visualLineEnd(e){let t;for(;t=collapsedSpanAtEnd(e);)e=t.find(1,!0).line;return e}export function visualLineContinued(e){let t,n;for(;t=collapsedSpanAtEnd(e);)e=t.find(1,!0).line,(n||(n=[])).push(e);return n}export function visualLineNo(e,t){let n=getLine(e,t),r=visualLine(n);return n==r?t:lineNo(r)}export function visualLineEndNo(e,t){if(t>e.lastLine())return t;let n,r=getLine(e,t);if(!lineIsHidden(e,r))return t;for(;n=collapsedSpanAtEnd(r);)r=n.find(1,!0).line;return lineNo(r)+1}export function lineIsHidden(e,t){let n=sawCollapsedSpans&&t.markedSpans;if(n)for(let r,l=0;l<n.length;++l)if(r=n[l],r.marker.collapsed){if(null==r.from)return!0;if(!r.marker.widgetNode&&0==r.from&&r.marker.inclusiveLeft&&lineIsHiddenInner(e,t,r))return!0}}function lineIsHiddenInner(e,t,n){if(null==n.to){let t=n.marker.find(1,!0);return lineIsHiddenInner(e,t.line,getMarkedSpanFor(t.line.markedSpans,n.marker))}if(n.marker.inclusiveRight&&n.to==t.text.length)return!0;for(let r,l=0;l<t.markedSpans.length;++l)if(r=t.markedSpans[l],r.marker.collapsed&&!r.marker.widgetNode&&r.from==n.to&&(null==r.to||r.to!=n.from)&&(r.marker.inclusiveLeft||n.marker.inclusiveRight)&&lineIsHiddenInner(e,t,r))return!0}export function heightAtLine(e){let t=0,n=(e=visualLine(e)).parent;for(let r=0;r<n.lines.length;++r){let l=n.lines[r];if(l==e)break;t+=l.height}for(let e=n.parent;e;n=e,e=n.parent)for(let r=0;r<e.children.length;++r){let l=e.children[r];if(l==n)break;t+=l.height}return t}export function lineLength(e){if(0==e.height)return 0;let t,n=e.text.length,r=e;for(;t=collapsedSpanAtStart(r);){let e=t.find(0,!0);r=e.from.line,n+=e.from.ch-e.to.ch}for(r=e;t=collapsedSpanAtEnd(r);){let e=t.find(0,!0);n-=r.text.length-e.from.ch,r=e.to.line,n+=r.text.length-e.to.ch}return n}export function findMaxLine(e){let t=e.display,n=e.doc;t.maxLine=getLine(n,n.first),t.maxLineLength=lineLength(t.maxLine),t.maxLineChanged=!0,n.iter((e=>{let n=lineLength(e);n>t.maxLineLength&&(t.maxLineLength=n,t.maxLine=e)}))}