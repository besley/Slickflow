import{runInOp}from"../display/operations.js";import{ensureCursorVisible}from"../display/scrolling.js";import{Pos}from"../line/pos.js";import{getLine}from"../line/utils_line.js";import{makeChange}from"../model/changes.js";import{ios,webkit}from"../util/browser.js";import{elt}from"../util/dom.js";import{lst,map}from"../util/misc.js";import{signalLater}from"../util/operation_group.js";import{splitLinesAuto}from"../util/feature_detection.js";import{indentLine}from"./indent.js";export let lastCopied=null;export function setLastCopied(e){lastCopied=e}export function applyTextInput(e,t,i,n,l){let o=e.doc;e.display.shift=!1,n||(n=o.sel);let r=+new Date-200,s="paste"==l||e.state.pasteIncoming>r,a=splitLinesAuto(t),p=null;if(s&&n.ranges.length>1)if(lastCopied&&lastCopied.text.join("\n")==t){if(n.ranges.length%lastCopied.text.length==0){p=[];for(let e=0;e<lastCopied.text.length;e++)p.push(o.splitLines(lastCopied.text[e]))}}else a.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(p=map(a,(e=>[e])));let c=e.curOp.updateInput;for(let t=n.ranges.length-1;t>=0;t--){let c=n.ranges[t],u=c.from(),d=c.to();c.empty()&&(i&&i>0?u=Pos(u.line,u.ch-i):e.state.overwrite&&!s?d=Pos(d.line,Math.min(getLine(o,d.line).text.length,d.ch+lst(a).length)):s&&lastCopied&&lastCopied.lineWise&&lastCopied.text.join("\n")==a.join("\n")&&(u=d=Pos(u.line,0)));let h={from:u,to:d,text:p?p[t%p.length]:a,origin:l||(s?"paste":e.state.cutIncoming>r?"cut":"+input")};makeChange(e.doc,h),signalLater(e,"inputRead",e,h)}t&&!s&&triggerElectric(e,t),ensureCursorVisible(e),e.curOp.updateInput<2&&(e.curOp.updateInput=c),e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=-1}export function handlePaste(e,t){let i=e.clipboardData&&e.clipboardData.getData("Text");if(i)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||runInOp(t,(()=>applyTextInput(t,i,0,null,"paste"))),!0}export function triggerElectric(e,t){if(!e.options.electricChars||!e.options.smartIndent)return;let i=e.doc.sel;for(let n=i.ranges.length-1;n>=0;n--){let l=i.ranges[n];if(l.head.ch>100||n&&i.ranges[n-1].head.line==l.head.line)continue;let o=e.getModeAt(l.head),r=!1;if(o.electricChars){for(let i=0;i<o.electricChars.length;i++)if(t.indexOf(o.electricChars.charAt(i))>-1){r=indentLine(e,l.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(getLine(e.doc,l.head.line).text.slice(0,l.head.ch))&&(r=indentLine(e,l.head.line,"smart"));r&&signalLater(e,"electricInput",e,l.head.line)}}export function copyableRanges(e){let t=[],i=[];for(let n=0;n<e.doc.sel.ranges.length;n++){let l=e.doc.sel.ranges[n].head.line,o={anchor:Pos(l,0),head:Pos(l+1,0)};i.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:i}}export function disableBrowserMagic(e,t,i,n){e.setAttribute("autocorrect",i?"":"off"),e.setAttribute("autocapitalize",n?"":"off"),e.setAttribute("spellcheck",!!t)}export function hiddenTextarea(){let e=elt("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none"),t=elt("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return webkit?e.style.width="1000px":e.setAttribute("wrap","off"),ios&&(e.style.border="1px solid black"),disableBrowserMagic(e),t}